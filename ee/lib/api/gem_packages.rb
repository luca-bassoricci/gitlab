# frozen_string_literal: true
module API
  class GemPackages < Grape::API
    GEM_ENDPOINT_REQUIREMENTS = {
      package_name: API::NO_SLASH_URL_PART_REGEX
    }.freeze

    before do
      require_packages_enabled!
      authenticate_non_get!
    end

    helpers ::API::Helpers::PackagesHelpers

    helpers do
      def find_project_by_package_name(name)
        Project.find_by_full_path(name.sub('@', ''))
      end

      def project_package_name_match?
        "@#{user_project.full_path}" == params[:package_name]
      end

      def ensure_project_package_match!
        bad_request!(:package_name) unless project_package_name_match?
      end
    end

    desc 'GEM registry endpoint at instance level' do
      detail 'This feature was introduced in GitLab 11.8'
    end
    params do
      requires :package_name, type: String, desc: 'Package name'
    end
    get 'packages/gem/*package_name', format: false, requirements: GEM_ENDPOINT_REQUIREMENTS do
      package_name = params[:package_name]

      # To avoid name collision we require project path and project package be the same.
      project = find_project_by_package_name(package_name)

      authorize!(:read_package, project)
      forbidden! unless project.feature_available?(:packages)

      packages = project.packages.gem.with_name(package_name).last_of_each_version.preload_files

      present GemPackagePresenter.new(project, package_name, packages),
        with: EE::API::Entities::GemPackage
    end

    params do
      requires :id, type: String, desc: 'The ID of a project'
    end
    resource :projects, requirements: API::NAMESPACE_OR_PROJECT_REQUIREMENTS do
      before do
        authorize_packages_feature!
        ensure_project_package_match!
      end

      desc 'Download the GEM tarball' do
        detail 'This feature was introduced in GitLab 11.8'
      end
      params do
        requires :package_name, type: String, desc: 'Package name'
        requires :file_name, type: String, desc: 'Package file name'
      end
      get ':id/packages/gem/:package_name/-/:file_name', format: false do
        puts "#{self.class.name} : #{__method__} : params: #{params.inspect}"

        authorize_download_package!

        package = user_project.packages.gem
          .by_name_and_file_name(params[:package_name], params[:file_name])

        package_file = ::Packages::PackageFileFinder
          .new(package, params[:file_name]).execute!

        present_carrierwave_file!(package_file.file)
      end

      desc 'Upload the gem package file' do
        detail 'This feature was introduced in GitLab 11.3'
      end
      params do
        requires :path, type: String, desc: 'Package path'
        requires :file_name, type: String, desc: 'Package file name'
      end
      route_setting :authentication, job_token_allowed: true
      post ':id/packages/gem/*path/:file_name/authorize', requirements: GEM_ENDPOINT_REQUIREMENTS do
        puts "#{self.class.name} : #{__method__} : params: #{params.inspect}"
        authorize_create_package!

        require_gitlab_workhorse!
        Gitlab::Workhorse.verify_api_request!(headers)

        status 200
        content_type Gitlab::Workhorse::INTERNAL_API_CONTENT_TYPE
        ::Packages::PackageFileUploader.workhorse_authorize(has_length: true)
      end

      desc 'Upload the gem package file' do
        detail 'This feature was introduced in GitLab 11.3'
      end
      params do
        requires :path, type: String, desc: 'Package path'
        requires :file_name, type: String, desc: 'Package file name'
        optional 'file.path', type: String, desc: %q(path to locally stored body (generated by Workhorse))
        optional 'file.name', type: String, desc: %q(real filename as send in Content-Disposition (generated by Workhorse))
        optional 'file.type', type: String, desc: %q(real content type as send in Content-Type (generated by Workhorse))
        optional 'file.size', type: Integer, desc: %q(real size of file (generated by Workhorse))
        optional 'file.md5', type: String, desc: %q(md5 checksum of the file (generated by Workhorse))
        optional 'file.sha1', type: String, desc: %q(sha1 checksum of the file (generated by Workhorse))
        optional 'file.sha256', type: String, desc: %q(sha256 checksum of the file (generated by Workhorse))
      end
      route_setting :authentication, job_token_allowed: true
      post ':id/packages/gem/*path/:file_name', requirements: GEM_ENDPOINT_REQUIREMENTS do
        authorize_create_package!
        require_gitlab_workhorse!

        file_name, format = extract_format(params[:file_name])

        uploaded_file = UploadedFile.from_params(params, :file, ::Packages::PackageFileUploader.workhorse_local_upload_path)
        bad_request!('Missing package file!') unless uploaded_file

        package = ::Packages::FindOrCreateMavenPackageService
          .new(user_project, current_user, params).execute

        case format
        when 'sha1'
          # After uploading a file, Maven tries to upload a sha1 and md5 version of it.
          # Since we store md5/sha1 in database we simply need to validate our hash
          # against one uploaded by Maven. We do this for `sha1` format.
          package_file = ::Packages::PackageFileFinder
            .new(package, file_name).execute!

          verify_package_file(package_file, uploaded_file)
        when nil
          file_params = {
            file:      uploaded_file,
            size:      params['file.size'],
            file_name: file_name,
            file_type: params['file.type'],
            file_sha1: params['file.sha1'],
            file_md5:  params['file.md5']
          }

          ::Packages::CreatePackageFileService.new(package, file_params).execute
        end
      end
    end
  end
end
